{"name":"React Keydown","tagline":"Lightweight keydown wrapper for React components","body":"# React Keydown\r\n> Lightweight keydown wrapper for React components.\r\n\r\nUse react-keydown as a higher-order component or decorator to pass keydown\r\nevents to the wrapped component, or call methods directly via designated keys. Good \r\nfor implementing keyboard navigation or other shortcuts.\r\n\r\nKey advantages:\r\n\r\n* **Declarative syntax**: Components say what keys they will respond to.\r\n* **Intuitive DX**: Decorate a class or method to bind it to specified keys.\r\n* **Scoping**: Designate the scope of your bindings by decorating/wrapping components. Only those components and their children will receive the designated key events, and then only when they appear to be active.\r\n* **Modifier keys**: Support for standard modifier key combinations.\r\n* **Lightweight**: 2kb compressed and gzipped, and only attaches a single keydown listener to document, no matter how many keybindings you specify.\r\n\r\nConsult the [API & Reference Documentation](https://github.com/jedverity/react-keydown/wiki/API-&-Reference) or continue reading below for quick start.\r\n\r\n**NOTE**: If react-keydown isn't working for you and you're using Babel 6, check [this phabricator thread](https://phabricator.babeljs.io/T2645) for updates on Babel's decorator implementation.\r\n\r\n## Install\r\n\r\n```\r\nnpm install --save react-keydown\r\n```\r\n**Note on versions**: Latest releases (1.4+) are meant to be used with React 0.14. If you are on 0.13- use the 1.3 version.\r\n\r\n## Use\r\n\r\nThe default build of react-keydown uses the CommonJS module system. For\r\nAMD or other support, use the [umd-specific\r\nbranch](https://github.com/jedverity/react-keydown/tree/master-umd) instead.\r\n\r\n### For methods: Decorate with keys that should trigger method\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport keydown from 'react-keydown';\r\n\r\nclass MyComponent extends React.Component {\r\n\r\n  @keydown( 'enter' ) // or specify `which` code directly, in this case 13\r\n  submit( event ) {\r\n    // do something, or not, with the keydown event, maybe event.preventDefault()\r\n    MyApi.post( this.state );\r\n  }\r\n}\r\n```\r\n\r\nNote: Since the only context we have for keydown events is the component, decorated methods receive the event as their sole argument and the component instance as context.\r\n\r\n#### Specify multiple keys that should trigger the method\r\n\r\n```javascript\r\nimport keydown, { Keys } from 'react-keydown';\r\n\r\nconst { ENTER, TAB } = Keys; // optionally get key codes from Keys lib to check against later\r\n\r\n@keydown( ENTER, TAB, 'ctrl+z' ) // could also be an array\r\nautocomplete( event ) {\r\n  if ( event.which === ENTER ) { ... }\r\n  MyApi.get( this.state );\r\n}\r\n```\r\n\r\n### For classes: Pass keydown events into your component\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport keydown from 'react-keydown';\r\n\r\nclass MyComponent extends React.Component {\r\n\r\n  componentWillReceiveProps( { keydown } ) {\r\n    if ( keydown.event ) {\r\n      // inspect the keydown event and decide what to do\r\n      console.log( keydown.event.which );\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>keydown events will only get passed down after this DOM node mounts or is clicked on</div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default keydown( MyComponent );\r\n```\r\n\r\n#### Use decorator pattern:\r\n\r\n```javascript\r\n@keydown\r\nclass MyComponent extends React.Component {\r\n  ...\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n#### Monitor only key codes `which` you care about:\r\n\r\n```javascript\r\nconst KEYS = [ 'shift+up', 'shift+down', 'enter', 'j', 'k', 'h', 'l' ];\r\n\r\n@keydown( KEYS )\r\nclass MyComponent extends React.Component {\r\n  ...\r\n}\r\n```\r\n\r\n#### Use the `@keydownScoped` shortcut\r\n\r\nWhen using the class decorator/higher-order component, decorate methods with `@keydownScoped` to identify the `keydown.event` prop as it comes in and bind certain values to methods:\r\n\r\n```javascript\r\nimport keydown, { keydownScoped } from 'react-keydown';\r\n\r\n@keydown( 'enter' ) // optional to specify a key here. if called with just @keydown, all key events will get passed down\r\nclass MyComponent extends React.Component {\r\n  render() {\r\n    return <MyOtherComponent {...this.props} />;\r\n  }\r\n}\r\n\r\nclass MyOtherComponent extends React.Component {\r\n  ...\r\n  @keydownScoped( 'enter' ) // inspects nextProps.keydown.event in componentWillReceiveProps behind the scenes\r\n  submit() {\r\n    // submit\r\n  }\r\n}\r\n```\r\n\r\nThis is a convenience method, but also lets you specify a larger view context where this key binding should be active. Sometimes the component where the binding is declared is too small on its own.\r\n\r\nThis can also be a good way to set up app-wide shortcuts. Wrap your root component with `@keydown` and then use  `@keydownScoped` or manually inspect the `keydown.event` props in the child components where those bindings are relevant.\r\n\r\n## Demo\r\n\r\nGo to the [live\r\ndemo](http://jedverity.github.io/react-keydown/example/index.html) or:\r\n\r\n```\r\n$ open example/public/index.html\r\n```\r\n\r\nNote that this is very much a work in progress!\r\n\r\n## Test\r\n\r\n```\r\n$ npm test\r\n```\r\n\r\n## Notes, disclaimers, and tips\r\n\r\n* The decorator pattern `@keydown` currently requires transpilation by\r\n  [Babel](babeljs.io/) (set to stage 1) or the equivalent.\r\n* The default build uses CommonJS modules. For AMD or other support, use the\r\n  [umd-specific\r\n  branch](https://github.com/jedverity/react-keydown/tree/master-umd) instead.\r\n* This lib has only been tested using ES2015 classes. Some method decoration\r\n  functionality may work on other types of object methods.\r\n* Duplicate keybindings for components that are mounted at the same time will\r\n  not both fire. The more recently mounted component, or the one that has been\r\n  focused or clicked most recently, will win. If you do want both to fire,\r\n  decorate a common ancestor class with `@keydown( ... )` and then use\r\n  `@keydownScoped( ... )` in the child components (or just inspect\r\n  `nextProps.keydown.event` in both).\r\n* Since the only context we have for keydown events is the component, decorated\r\n  methods receive the event as their sole argument and the component instance as\r\n  context.\r\n* The method decorators wrap React lifecycle methods in order to work\r\n  as seamlessly and efficiently as possible. The class decorator does not do\r\n  this, functioning instead as a higher-order component.\r\n\r\n## Questions\r\n\r\nWhy is this so limited, only working on `keydown` and such?\r\n\r\n> I published this out of my particular need on a project. If anyone else ever\r\narrives here and needs something else let me know via issues or a pull request.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}