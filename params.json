{"name":"React Keydown","tagline":"Lightweight keydown wrapper for React components","body":"# React Keydown\r\n> Lightweight keydown wrapper for React components.\r\n\r\nUse react-keydown as a higher-order component or decorator to pass keydown\r\nevents to the wrapped component, or call methods directly via designated keys. Good \r\nfor implementing keyboard navigation or other shortcuts.\r\n\r\nKey advantages:\r\n\r\n* **Declarative syntax**: Components say what keys they will respond to.\r\n* **Intuitive DX**: Decorate a class or method to bind it to specified keys.\r\n* **Scoping**: Designate the scope of your bindings by decorating/wrapping components. Only those components and their children will receive the designated key events.\r\n* **Modifier keys**: Support for standard modifier key combinations.\r\n* **Tiny**: 2kb compressed and gzipped (with UMD module wrapping -- smaller\r\n  without it).\r\n\r\n## Install\r\n\r\n```\r\nnpm install --save react-keydown\r\n```\r\n\r\n## Use\r\n\r\n### For methods: Decorate with keys that should trigger method\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport keydown from 'react-keydown';\r\n\r\nclass MyComponent extends React.Component {\r\n\r\n  ...\r\n\r\n  @keydown( 'enter' ) // or specify `which` code directly, in this case 13\r\n  submit() {\r\n    MyApi.post( this.state );\r\n  }\r\n}\r\n```\r\n\r\nNote: The keydown event will be passed to the decorated method for further\r\nprocessing, if desired. For example, you may went to `event.preventDefault()`.\r\n\r\n#### Specify multiple keys that should trigger the method\r\n\r\n```javascript\r\n@keydown( 'enter', 'tab', 'ctrl+z' )\r\nautocomplete() {\r\n  MyApi.get( this.state );\r\n}\r\n```\r\n\r\n### For classes: Pass keydown events into your component\r\n\r\n```jsx\r\nimport React from 'react';\r\nimport keydown from 'react-keydown';\r\n\r\nclass MyComponent extends React.Component {\r\n\r\n  constructor( props ) {\r\n    super( props );\r\n  }\r\n\r\n  componentWillReceiveProps( { keydown } ) {\r\n    if ( keydown.event ) {\r\n      // inspect the keydown event and decide what to do\r\n      console.log( keydown.event.which );\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>keydown events will only get passed down after this DOM node mounts or is clicked on</div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default keydown( MyComponent );\r\n```\r\n\r\n#### Use decorator pattern:\r\n\r\n```javascript\r\n@keydown\r\nclass MyComponent extends React.Component {\r\n  ...\r\n}\r\n\r\nexport default MyComponent;\r\n```\r\n\r\n#### Monitor only key codes `which` you care about:\r\n\r\n```javascript\r\nconst KEYS = [ 'shift+up', 'shift+down', 'enter', 'j', 'k', 'h', 'l' ];\r\n\r\n@keydown( KEYS )\r\nclass MyComponent extends React.Component {\r\n  ...\r\n}\r\n```\r\n\r\n#### Use the `@keydownScoped` shortcut\r\n\r\nWhen using the class decorator/higher-order component, decorate methods with `@keydownScoped` to identify the `keydown.event` prop as it comes in and bind certain values to methods:\r\n\r\n```javascript\r\nimport keydown, { keydownScoped } from 'react-keydown';\r\n\r\n@keydown( 'enter' ) // optional to specify a key here. if called with just @keydown, all key events will get passed down\r\nclass MyComponent extends React.Component {\r\n  render() {\r\n    return <MyOtherComponent {...this.props} />;\r\n  }\r\n}\r\n\r\nclass MyOtherComponent extends React.Component {\r\n  ...\r\n  @keydownScoped( 'enter' ) // inspects nextProps.keydown.event in componentWillReceiveProps behind the scenes\r\n  submit() {\r\n    // submit\r\n  }\r\n}\r\n```\r\n\r\nThis is a convenience method, but also lets you specify a larger view context where this key binding should be active. Sometimes the component where the binding is declared is too small on its own.\r\n\r\nThis can also be a good way to set up app-wide shortcuts. Wrap your root component with `@keydown` and then use  `@keydownScoped` or manually inspect the `keydown.event` props in the child components where those bindings are relevant.\r\n\r\n## Demo\r\n\r\nGo to the [live\r\ndemo](http://jedverity.github.io/react-keydown/example/index.html) or:\r\n\r\n```\r\n$ open example/public/index.html\r\n```\r\n\r\nNote that this is very much a work in progress!\r\n\r\n## Notes and disclaimers\r\n\r\n* The decorator pattern `@keydown` currently requires transpilation by\r\n  [Babel](babeljs.io/) (set to\r\n  stage 1) or the equivalent\r\n* This lib has only been tested using ES2015 classes. Some method decoration\r\n  functionality may work on other types of object methods.\r\n* In order to avoid unintended side effects, only one component (and its children) can receive\r\n  keydown events at a time (the most recently mounted, clicked, or focused component). If you want multiple     \r\n  components to receive keydown events simultaneously, decorate a common ancestor component class with `@keydown`     and then decorate your methods in the child components with `@keydownScoped( myKeyCode )` (or manually work with    the keydown.event props flowing into your components). For example, if you want app-wide shortcuts, decorate (or    wrap) the root component with `@keydown` and then all descendent components will receive the `keydown.event` prop   when a key is pressed.\r\n* Since the only context we have for keydown events is the component, decorated\r\n  methods receive the event as their sole argument and the component instance as\r\n  context.\r\n* The method decorators wrap React lifecycle methods in order to work\r\n  as seamlessly and efficiently as possible. The class decorator does not do\r\n  this, functioning instead as a higher-order component.\r\n\r\n## Questions\r\n\r\nWhy is this so limited, only working on `keydown` and such?\r\n\r\n> I published this out of my particular need on a project. If anyone else ever\r\narrives here and needs something else let me know via issues or a pull request.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}